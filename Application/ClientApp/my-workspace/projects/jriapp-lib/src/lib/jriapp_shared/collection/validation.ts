/** The MIT License (MIT) Copyright(c) 2016-present Maxim V.Tsapov */
import { DATA_TYPE } from "./const";
import { IFieldInfo } from "./int";
import { ERRS } from "../../lang";
import { Utils } from "../utils/utils";
import { IIndexer, IValidationInfo } from "../int";


const utils = Utils, { Indexer } = utils.core, { isGuid, isNumber, isString, isArray, isDate, isBoolean } = utils.check,
    { format } = utils.str;

function fn_toArray(index: IIndexer<IValidationInfo>): IValidationInfo[] {
    const keys = Object.keys(index), result: IValidationInfo[] = [], len = keys.length;
    for (let i = 0; i < len; i += 1) {
        result.push(index[keys[i]]);
    }
    return result;
}


export class Validations {
    private static _dtRangeToDate(str: string) {
        const dtParts = str.split("-"), dt = new Date(parseInt(dtParts[0], 10), parseInt(dtParts[1], 10) - 1, parseInt(dtParts[2], 10));
        return dt;
    }
    private static checkNumRange(num: number, range: string): string[] {
        const errors: string[] = [], rangeParts = range.split(",");
        if (!!rangeParts[0]) {
            if (num < parseFloat(rangeParts[0])) {
                errors.push(utils.str.format(ERRS.ERR_FIELD_RANGE, num, range));
            }
        }
        if (!!rangeParts[1]) {
            if (num > parseFloat(rangeParts[1])) {
                errors.push(utils.str.format(ERRS.ERR_FIELD_RANGE, num, range));
            }
        }
        return errors;
    }
    private static checkDateRange(dt: Date, range: string): string[] {
        const errors: string[] = [], rangeParts = range.split(",");
        if (!!rangeParts[0]) {
            if (dt < Validations._dtRangeToDate(rangeParts[0])) {
                errors.push(utils.str.format(ERRS.ERR_FIELD_RANGE, dt, range));
            }
        }
        if (!!rangeParts[1]) {
            if (dt > Validations._dtRangeToDate(rangeParts[1])) {
                errors.push(utils.str.format(ERRS.ERR_FIELD_RANGE, dt, range));
            }
        }
        return errors;
    }
    static checkField(fieldInfo: IFieldInfo, value: any, isNew: boolean): string[] {
        const res: string[] = [];

        const isNullVal = (value === null || (isString(value) && !value));

        if (isNullVal && !fieldInfo.isNullable && !fieldInfo.isReadOnly) {
            if (!(isNew && fieldInfo.isAutoGenerated)) {
                res.push(ERRS.ERR_FIELD_ISNOT_NULLABLE);
            }
        }

        if (isNullVal) {
            return res;
        }

        switch (fieldInfo.dataType) {
            case DATA_TYPE.None:
                break;
            case DATA_TYPE.Guid:
                if (!isGuid(value)) {
                    res.push(format(ERRS.ERR_FIELD_WRONG_TYPE, value, "Guid"));
                }
                break;
            case DATA_TYPE.String:
                if (!isString(value)) {
                    res.push(format(ERRS.ERR_FIELD_WRONG_TYPE, value, "String"));
                }
                if (fieldInfo.maxLength > 0 && value.length > fieldInfo.maxLength) {
                    res.push(format(ERRS.ERR_FIELD_MAXLEN, fieldInfo.maxLength));
                }
                if (!!fieldInfo.regex) {
                    const reg = new RegExp(fieldInfo.regex, "i");
                    if (!reg.test(value)) {
                        res.push(format(ERRS.ERR_FIELD_REGEX, value));
                    }
                }
                break;
            case DATA_TYPE.Binary:
                if (!isArray(value)) {
                    res.push(format(ERRS.ERR_FIELD_WRONG_TYPE, value, "Array"));
                }
                if (fieldInfo.maxLength > 0 && value.length > fieldInfo.maxLength) {
                    res.push(format(ERRS.ERR_FIELD_MAXLEN, fieldInfo.maxLength));
                }
                break;
            case DATA_TYPE.Bool:
                if (!isBoolean(value)) {
                    res.push(format(ERRS.ERR_FIELD_WRONG_TYPE, value, "Boolean"));
                }
                break;
            case DATA_TYPE.Integer:
            case DATA_TYPE.Decimal:
            case DATA_TYPE.Float:
                if (!isNumber(value)) {
                    res.push(format(ERRS.ERR_FIELD_WRONG_TYPE, value, "Number"));
                }
                if (!!fieldInfo.range) {
                    Validations.checkNumRange(Number(value), fieldInfo.range).forEach((err) => {
                        res.push(err);
                    });
                }
                break;
            case DATA_TYPE.DateTime:
            case DATA_TYPE.Date:
                if (!isDate(value)) {
                    res.push(format(ERRS.ERR_FIELD_WRONG_TYPE, value, "Date"));
                }
                if (!!fieldInfo.range) {
                    Validations.checkDateRange(value, fieldInfo.range).forEach((err) => {
                        res.push(err);
                    });
                }
                break;
            case DATA_TYPE.Time:
                if (!isDate(value)) {
                    res.push(format(ERRS.ERR_FIELD_WRONG_TYPE, value, "Time"));
                }
                break;
            default:
                res.push(format(ERRS.ERR_PARAM_INVALID, "dataType", fieldInfo.dataType));
        }

        return res;
    }
    static distinct(vals: IValidationInfo[]): IValidationInfo[] {
        if (!vals) {
            return [];
        }

        const index = Indexer<IValidationInfo>();
        for(const val of vals)
        {
            const name = !val.fieldName ? "*" : val.fieldName;
            const test = index[name];
            if (!!test) {
                test.errors = test.errors.concat(val.errors);
            } else {
                index[name] = val;
            }
        }

        return fn_toArray(index);
    }
}
